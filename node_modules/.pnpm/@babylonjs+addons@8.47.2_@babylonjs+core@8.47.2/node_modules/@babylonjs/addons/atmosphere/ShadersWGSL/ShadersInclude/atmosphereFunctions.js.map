{"version":3,"file":"atmosphereFunctions.js","sourceRoot":"","sources":["../../../../../../dev/addons/src/atmosphere/ShadersWGSL/ShadersInclude/atmosphereFunctions.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,+CAAiC;AAEvD,MAAM,IAAI,GAAG,qBAAqB,CAAC;AACnC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwDd,CAAC;AACF,aAAa;AACb,IAAI,CAAC,WAAW,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAE,CAAC;IAC9C,WAAW,CAAC,wBAAwB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxD,CAAC;AACD,gBAAgB;AAChB,MAAM,CAAC,MAAM,uBAAuB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"atmosphereFunctions\";\nconst shader = `const NumAerialPerspectiveLutLayers: f32=32.0;const AerialPerspectiveLutSize: vec3f=vec3f(16.0,64.0,NumAerialPerspectiveLutLayers);const AerialPerspectiveLutKMPerSlice: f32=4.0;const AerialPerspectiveLutRangeKM: f32=AerialPerspectiveLutKMPerSlice*NumAerialPerspectiveLutLayers;const TransmittanceSampleCount: i32=128;const TransmittanceLutSize: vec2f=vec2f(256.0,64.0);const TransmittanceLutDomainInUVSpace: vec2f=(TransmittanceLutSize-vec2f(1.0,1.0))/TransmittanceLutSize;const TransmittanceLutHalfTexelSize: vec2f=vec2f(0.5,0.5)/TransmittanceLutSize;const TransmittanceHorizonRange: f32=2.0*TransmittanceLutHalfTexelSize.x;const TransmittanceMaxUnoccludedU: f32=1.0-0.5*TransmittanceHorizonRange;const TransmittanceMinOccludedU: f32=1.0+0.5*TransmittanceHorizonRange;fn uvToUnit(uv: vec2f,domainInUVSpace: vec2f,halfTexelSize: vec2f)->vec2f {return (uv-halfTexelSize)/domainInUVSpace;}\nfn computeOzoneDensity(normalizedViewHeight: f32)->f32 {let MinOzoneDensity: f32=0.135;let OneMinusMinOzoneDensity: f32=1.0-MinOzoneDensity;let OzoneStartHeight: f32=0.15; \nlet PeakOzoneHeight: f32=0.25;let MaxOzoneHeight: f32=0.6;let InverseRampupDistance: f32=1.0/(PeakOzoneHeight-OzoneStartHeight);let InverseRampdownDistance: f32=1.0/(MaxOzoneHeight-PeakOzoneHeight);let lowerAtmosphereDensity=MinOzoneDensity+OneMinusMinOzoneDensity*max(0.0,normalizedViewHeight-OzoneStartHeight)*InverseRampupDistance;let sqrtUpperAtmosphereDensity=max(0.0,1.0-(normalizedViewHeight-PeakOzoneHeight)*InverseRampdownDistance);let upperAtmosphereDensity=sqrtUpperAtmosphereDensity*sqrtUpperAtmosphereDensity;return select(upperAtmosphereDensity,lowerAtmosphereDensity,normalizedViewHeight<PeakOzoneHeight);}\nfn sampleMediumRGB(\nviewHeight: f32,\nscatteringRayleigh: ptr<function,vec3f>,\nscatteringMie: ptr<function,vec3f>,\nextinction: ptr<function,vec3f>,\nscattering: ptr<function,vec3f>\n) {let normalizedViewHeight=saturate(viewHeight*atmosphere.inverseAtmosphereThickness);let densityMie=exp(-83.333*normalizedViewHeight);let densityRayleigh=exp(-12.5*normalizedViewHeight);let densityOzone=computeOzoneDensity(normalizedViewHeight);*scatteringRayleigh=densityRayleigh*atmosphere.peakRayleighScattering;*scatteringMie=densityMie*atmosphere.peakMieScattering;*scattering=*scatteringMie+*scatteringRayleigh;let extinctionRayleigh=*scatteringRayleigh;let extinctionMie=densityMie*atmosphere.peakMieExtinction;let extinctionOzone=densityOzone*atmosphere.peakOzoneAbsorption;*extinction=extinctionRayleigh+extinctionMie+extinctionOzone;}\nfn computeTransmittance(rayOriginGlobal: vec3f,rayDirection: vec3f,tMax: f32,sampleCount: i32)->vec3f {var opticalDepth: vec3f=vec3f(0.0);var t: f32=0.0;let sampleSegmentWeight=tMax/f32(sampleCount);let sampleSegmentT: f32=0.3;for (var s: i32=0; s<sampleCount; s+=1) {let newT=sampleSegmentWeight*(f32(s)+sampleSegmentT);let dt=newT-t;t=newT;var scatteringRayleigh: vec3f;var scatteringMie: vec3f;var extinction: vec3f;var scattering: vec3f;let samplePositionGlobal=rayOriginGlobal+t*rayDirection;sampleMediumRGB(length(samplePositionGlobal)-atmosphere.planetRadius,&scatteringRayleigh,&scatteringMie,&extinction,&scattering);opticalDepth+=extinction*dt;}\nreturn exp(-opticalDepth);}\n#if defined(SAMPLE_TRANSMITTANCE_LUT) || !defined(EXCLUDE_RAY_MARCHING_FUNCTIONS)\nfn getTransmittanceUV(radius: f32,cosAngleLightToZenith: f32,distanceToHorizon: ptr<function,f32>)->vec2f {let radiusSquared=radius*radius;let horizonDistance=sqrtClamped(radiusSquared-atmosphere.planetRadiusSquared);*distanceToHorizon=horizonDistance;let cosAngleLightToZenithSquared=cosAngleLightToZenith*cosAngleLightToZenith;let discriminant=radiusSquared*(cosAngleLightToZenithSquared-1.0)+atmosphere.atmosphereRadiusSquared;let distanceToAtmosphereEdge=max(0.0,-radius*cosAngleLightToZenith+sqrtClamped(discriminant));let minDistanceToAtmosphereEdge=max(0.0,atmosphere.atmosphereRadius-radius);let maxDistanceToAtmosphereEdge=horizonDistance+atmosphere.horizonDistanceToAtmosphereEdge;let cosAngleLightToZenithCoordinate=(distanceToAtmosphereEdge-minDistanceToAtmosphereEdge)/max(0.000001,maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);let distanceToHorizonCoordinate=horizonDistance/max(0.000001,atmosphere.horizonDistanceToAtmosphereEdge);let unit=vec2f(cosAngleLightToZenithCoordinate,distanceToHorizonCoordinate);return unit*TransmittanceLutDomainInUVSpace+TransmittanceLutHalfTexelSize;}\nfn sampleTransmittanceLut(transmittanceLut: texture_2d<f32>,positionRadius: f32,cosAngleLightToZenith: f32)->vec4f {var distanceToHorizon=0.0;let uv=getTransmittanceUV(positionRadius,cosAngleLightToZenith,&distanceToHorizon);let weight=smoothstep(TransmittanceMinOccludedU,TransmittanceMaxUnoccludedU,uv.x);return weight*textureSampleLevel(transmittanceLut,transmittanceLutSampler,uv,0.0);}\n#endif\nfn layerIdxToAerialPerspectiveLayer(layerIdx: f32)->f32 {var layer=(layerIdx+1.0)/NumAerialPerspectiveLutLayers;layer*=layer; \nlayer*=NumAerialPerspectiveLutLayers;return layer;}\nfn toAerialPerspectiveDepth(layer: f32)->f32 {return layer*AerialPerspectiveLutKMPerSlice;}\nfn toAerialPerspectiveLayer(distance: f32,aerialPerspectiveLutDistancePerSlice: f32)->f32 {return distance/aerialPerspectiveLutDistancePerSlice;}\nfn applyAerialPerspectiveSaturation(aerialPerspective: vec4f)->vec4f {let previousRadiance=getLuminance(aerialPerspective.rgb);let mixed=mix(vec3f(previousRadiance),aerialPerspective.rgb,atmosphere.aerialPerspectiveSaturation);return vec4f(mixed,aerialPerspective.a);}\nfn applyAerialPerspectiveIntensity(aerialPerspective: vec4f)->vec4f {var result=aerialPerspective;\n#if APPLY_AERIAL_PERSPECTIVE_INTENSITY\nif (atmosphere.aerialPerspectiveIntensity==0.0) {result=vec4f(0.0);} else {let previousAlpha=result.a;result=result/max(0.00001,previousAlpha);result=result*pow(previousAlpha,1.0/atmosphere.aerialPerspectiveIntensity);}\n#endif\nreturn result;}\nfn applyAerialPerspectiveRadianceBias(aerialPerspective: vec4f)->vec4f {var result=aerialPerspective;\n#if APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\nlet originalRadiance=dot(result.rgb,LuminanceEncodeApprox);let targetRadiance=originalRadiance+atmosphere.aerialPerspectiveRadianceBias;if (originalRadiance>0.0) {result=result*max(0.0,targetRadiance/originalRadiance);} else {result=max(vec4f(0.0),vec4f(atmosphere.aerialPerspectiveRadianceBias));}\nresult.a=min(result.a,1.0);\n#endif\nreturn result;}\nfn sampleAerialPerspectiveLut(\nscreenUV: vec2f,\nclampToLutRange: bool,\ndistanceFromCamera: f32,\nnumAerialPerspectiveLutLayers: f32,\naerialPerspectiveLutKMPerSlice: f32,\naerialPerspectiveLutRangeKM: f32,\naerialPerspective: ptr<function,vec4f>\n)->bool {*aerialPerspective=vec4f(0.0);\n#if USE_AERIAL_PERSPECTIVE_LUT\nif (distanceFromCamera>0.0 &&\n(clampToLutRange || distanceFromCamera<aerialPerspectiveLutRangeKM) &&\natmosphere.clampedCameraRadius<=atmosphere.atmosphereRadius) {var layer=toAerialPerspectiveLayer(distanceFromCamera,aerialPerspectiveLutKMPerSlice);let normalizedLayer=sqrt(layer/numAerialPerspectiveLutLayers); \nlayer=min(normalizedLayer*numAerialPerspectiveLutLayers,numAerialPerspectiveLutLayers);let weight=min(layer,1.0);let layerIdx=max(0.0,layer-1.0);let floorLayerIdx=floor(layerIdx);let aerialPerspectiveLayer0=textureSampleLevel(aerialPerspectiveLut,aerialPerspectiveLutSampler,screenUV,i32(floorLayerIdx),0.0);let aerialPerspectiveLayer1=textureSampleLevel(aerialPerspectiveLut,aerialPerspectiveLutSampler,screenUV,i32(floorLayerIdx+1.0),0.0);var interpolated=mix(aerialPerspectiveLayer0,aerialPerspectiveLayer1,layerIdx-floorLayerIdx);interpolated=vec4f(interpolated.rgb*atmosphere.atmosphereExposure,interpolated.a);interpolated=applyAerialPerspectiveSaturation(interpolated);interpolated=weight*applyAerialPerspectiveIntensity(interpolated);interpolated=applyAerialPerspectiveRadianceBias(interpolated);*aerialPerspective=interpolated;return true;}\n#endif\nreturn false;}\n#if RENDER_TRANSMITTANCE\nfn getTransmittanceParameters(uv: vec2f,radius: ptr<function,f32>,cosAngleLightToZenith: ptr<function,f32>,distanceToAtmosphereEdge: ptr<function,f32>) {let unit=uvToUnit(uv,TransmittanceLutDomainInUVSpace,TransmittanceLutHalfTexelSize);let distanceToHorizon=unit.y*atmosphere.horizonDistanceToAtmosphereEdge;let distanceToHorizonSquared=distanceToHorizon*distanceToHorizon;*radius=sqrtClamped(distanceToHorizonSquared+atmosphere.planetRadiusSquared);let minDistanceToAtmosphereEdge=atmosphere.atmosphereRadius-*radius;let maxDistanceToAtmosphereEdge=distanceToHorizon+atmosphere.horizonDistanceToAtmosphereEdge;*distanceToAtmosphereEdge=minDistanceToAtmosphereEdge+unit.x*(maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);let distanceToAtmosphereEdgeSquared=*distanceToAtmosphereEdge**distanceToAtmosphereEdge;*cosAngleLightToZenith=select(\n(atmosphere.horizonDistanceToAtmosphereEdgeSquared-distanceToAtmosphereEdgeSquared-distanceToHorizonSquared)/(2.0**radius**distanceToAtmosphereEdge),\n1.0,\n*distanceToAtmosphereEdge<=0.0\n);*cosAngleLightToZenith=clamp(*cosAngleLightToZenith,-1.0,1.0);}\nfn renderTransmittance(uv: vec2f)->vec4f {var radius: f32;var cosAngleLightToZenith: f32;var distanceToAtmosphereEdgeAlongAngle: f32;getTransmittanceParameters(uv,&radius,&cosAngleLightToZenith,&distanceToAtmosphereEdgeAlongAngle);let sinAngleLightToZenith=sqrtClamped(1.0-cosAngleLightToZenith*cosAngleLightToZenith);let directionToLight=normalize(vec3f(0.0,cosAngleLightToZenith,sinAngleLightToZenith));let transmittance=computeTransmittance(vec3f(0.0,radius,0.0),directionToLight,distanceToAtmosphereEdgeAlongAngle,TransmittanceSampleCount);return vec4f(transmittance,avg(transmittance));}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const atmosphereFunctionsWGSL = { name, shader };\n"]}